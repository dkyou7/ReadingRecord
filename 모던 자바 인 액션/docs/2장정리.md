# 동작 파라미터화 코드 전달하기

> 우리가 어떤 상황에서 일을 하든 소비자 요구사항은 항상 바뀐다.

그렇다면, 사용자 요구사항에 어떻게 대처해야할까? 가 이번 챕터의 주제같다.

- 답은 동적 파라미터화이다.

- 동적 파라미터
  - 아직 어떻게 실행할 것인지 결정하지 않은 코드 블록을 의미함

- 변화하는 요구사항에 대처하는 방법

1. 1.7 이하에서 쓰이던 방법

```java
// 녹색 사과만 꺼내보자.	
public static List<Apple> filterGreenApples(List<Apple> inventory){
    List<Apple> result = new ArrayList<>();
    for(Apple apple: inventory){
        if("green".equals(apple.getColor())){
            result.add(apple);
        }
    }
    return result;
}
```

- 이렇게 하면 다양한 색에 대처할 수 없다. filterRedApples, filterYelloApples... 비슷하지만 다른 함수를 만들어 대처해야하는데, 이는 좋지 않다고 한다.

2. 색을 파라메터화

- 이것도 1.7에서 나름 대처한다고 만든 방법이다. 스트링값으로 색을 전달하는것이다. 이렇게 하면 함수는 하나로 줄고 조금 더 유연해진다. 나도 이 방법으로 많이 구현했었다.

```java
public static List<Apple> filterApplesByColor(List<Apple> inventory, String color){
    List<Apple> result = new ArrayList<>();
    for(Apple apple: inventory){
        if(apple.getColor().equals(color)){
            result.add(apple);
        }
    }
    return result;
}
```

하지만, 이것도 단순히 색'만'을 기준으로 했을 때의 이야기이다. 무게를 조건으로 두는 요구사항이 추가된다면? 지역에 따라 다르게 받고싶다면? .... 이와 같은 방식으로 함수가 계속 만들어 질 것이다.

3. 가능한 모든 필터를 다 적용시키자.

- 임시 방편으로 다 파라메터로 추가시켜보자.

```java
public static List<Apple> filterApplesByColor(List<Apple> inventory, String color, String weight, String area){
    List<Apple> result = new ArrayList<>();
    for(Apple apple: inventory){
        if(apple.getColor().equals(color) 
           && apple.getArea().equals("서울") 
           && apple.getWeight()>150){
            result.add(apple);
        }else if(...){}
    }
    return result;
}
```

이 메서드를 활용하면 다음과 같은 끔찍한 혼종이 만들어진다.

```java
List<Apple> redApples = filterApplesByColor(inventory, "red","대전",150);
List<Apple> redApples = filterApplesByColor(inventory, "red","",80);
```

- 이러한 코드 대신 filterApple에 어떤 기준으로 필터링 할 것인지 '기준 자체'를 넣어 개선하는 것이 이 장의 핵심이다.

